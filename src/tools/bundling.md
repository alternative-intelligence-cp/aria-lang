Here is a comprehensive implementation plan to bundle `nasm`, a C compiler (we will use `tcc` - Tiny C Compiler - for its small footprint and embeddability), and the Aria runtime library (`libaria.a`) into your single compiler executable.

### Implementation Plan

1.  **Tool Acquisition**: You will need to download/build static binaries for `nasm` and `tcc` and place them in a `tools/` directory.
2.  **Binary-to-Source Converter**: We will modify the `Makefile` to compile a small utility (`bin2c`) that converts these binary files into C header files containing byte arrays.
3.  **Bundler Module**: Create a new runtime module (`src/runtime/bundler.c`) that:
      * Contains the embedded byte arrays for `nasm`, `tcc`, and `libaria.a`.
      * On startup, checks if these files exist in a temporary directory (e.g., `/tmp/aria_runtime_<uid>/`).
      * Extracts them if missing and sets executable permissions.
      * Exposes functions to get the paths of these tools.
4.  **Compiler Integration**: Modify `src/main.c` to initialize the bundler and use the extracted tool paths for the assembly and linking steps.
5.  **Runtime Embedding**: The `Makefile` will be updated to ensure `libaria.a` is built *before* the compiler, converted to a blob, and then embedded into the compiler.

### 1\. New File: `src/runtime/bundler.h`

This header exposes the bundling API to the compiler.

```c
/* Aria_lang/src/runtime/bundler.h */
#ifndef BUNDLER_H
#define BUNDLER_H

// Initializes the bundler: checks/extracts tools to a temp directory.
// Returns 1 on success, 0 on failure.
int bundler_init();

// Returns the absolute path to the extracted NASM binary.
const char* bundler_get_nasm_path();

// Returns the absolute path to the extracted TCC/GCC binary.
const char* bundler_get_cc_path();

// Returns the absolute path to the extracted Aria Runtime Library (libaria.a).
const char* bundler_get_runtime_path();

// Cleans up temporary files (optional, usually kept for caching).
void bundler_cleanup();

#endif
```

### 2\. New File: `src/runtime/bundler.c`

This file includes the generated blobs (created by the Makefile) and handles extraction.

```c
/* Aria_lang/src/runtime/bundler.c */
#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <fcntl.h>
#include <errno.h>
#include "bundler.h"

// These headers are generated by the Makefile
#if defined(ARIA_BUNDLE_TOOLS)
    #include "nasm_blob.h"
    #include "tcc_blob.h"
    #include "libaria_blob.h"
#else
    // Dummy data for development builds without bundling
    const unsigned char nasm_blob[] = {0};
    const unsigned int nasm_blob_len = 0;
    const unsigned char tcc_blob[] = {0};
    const unsigned int tcc_blob_len = 0;
    const unsigned char libaria_blob[] = {0};
    const unsigned int libaria_blob_len = 0;
#endif

static char tool_dir[256];
static char nasm_path[512];
static char cc_path[512];
static char runtime_path[512];
static int initialized = 0;

static void get_temp_dir(char* buffer, size_t size) {
    const char* tmp = getenv("TMPDIR");
    if (!tmp) tmp = "/tmp";
    snprintf(buffer, size, "%s/aria_rt_%d", tmp, getuid());
}

static int write_file_if_missing(const char* path, const unsigned char* data, unsigned int len, int executable) {
    // Check if file exists and has correct size (simple cache check)
    struct stat st;
    if (stat(path, &st) == 0) {
        if (st.st_size == len) return 1; // Assume valid
    }

    FILE* f = fopen(path, "wb");
    if (!f) {
        fprintf(stderr, "[Bundler] Failed to write %s: %s\n", path, strerror(errno));
        return 0;
    }
    
    size_t written = fwrite(data, 1, len, f);
    fclose(f);

    if (written != len) {
        fprintf(stderr, "[Bundler] Write incomplete for %s\n", path);
        return 0;
    }

    if (executable) {
        chmod(path, 0755);
    }
    return 1;
}

int bundler_init() {
    if (initialized) return 1;

    get_temp_dir(tool_dir, sizeof(tool_dir));
    
    // Create directory
    if (mkdir(tool_dir, 0755) != 0 && errno != EEXIST) {
        perror("[Bundler] mkdir failed");
        return 0;
    }

    snprintf(nasm_path, sizeof(nasm_path), "%s/nasm", tool_dir);
    snprintf(cc_path, sizeof(cc_path), "%s/tcc", tool_dir);
    snprintf(runtime_path, sizeof(runtime_path), "%s/libaria.a", tool_dir);

    // Extract Tools
    // Note: If blobs are empty (dev build), we assume tools are in PATH or handled externally
    if (nasm_blob_len > 0) {
        if (!write_file_if_missing(nasm_path, nasm_blob, nasm_blob_len, 1)) return 0;
    } else {
        strcpy(nasm_path, "nasm"); // Fallback to PATH
    }

    if (tcc_blob_len > 0) {
        if (!write_file_if_missing(cc_path, tcc_blob, tcc_blob_len, 1)) return 0;
    } else {
        strcpy(cc_path, "gcc"); // Fallback to PATH
    }

    if (libaria_blob_len > 0) {
        if (!write_file_if_missing(runtime_path, libaria_blob, libaria_blob_len, 0)) return 0;
    } else {
        // Fallback: assume lib/libaria.a relative to CWD
        strcpy(runtime_path, "lib/libaria.a");
    }

    initialized = 1;
    return 1;
}

const char* bundler_get_nasm_path() { return nasm_path; }
const char* bundler_get_cc_path() { return cc_path; }
const char* bundler_get_runtime_path() { return runtime_path; }

void bundler_cleanup() {
    // Optional: Implement rm -rf on tool_dir
}
```

### 3\. Modified File: `src/main.c`

This file is updated to use the bundler for finding tools.

```c
/* Aria_lang/src/main.c */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>
#include "frontend/ast.h"
#include "runtime/bundler.h"

// Defined in parser.c / lexer.c
extern AstNode* parse_program(AstArena* arena);
extern void init_lexer(const char* source);

// Defined in codegen.c
extern void gen_program(AstNode* head);
extern FILE* asm_out;

char* read_entire_file(const char* path) {
    FILE* f = fopen(path, "rb");
    if (!f) return NULL;
    
    fseek(f, 0, SEEK_END);
    long length = ftell(f);
    fseek(f, 0, SEEK_SET);
    
    char* buffer = malloc(length + 1);
    if (!buffer) { fclose(f); return NULL; }
    
    fread(buffer, 1, length, f);
    buffer[length] = '\0';
    fclose(f);
    return buffer;
}

void replace_extension(const char* filename, const char* new_ext, char* out_buf, size_t size) {
    const char* dot = strrchr(filename, '.');
    if (!dot) {
        snprintf(out_buf, size, "%s%s", filename, new_ext);
    } else {
        size_t base_len = dot - filename;
        snprintf(out_buf, size, "%.*s%s", (int)base_len, filename, new_ext);
    }
}

// Helper to safely execute a subprocess without shell injection
int run_command(char* const* argv) {
    pid_t pid = fork();
    if (pid == -1) {
        perror("fork");
        return 1;
    } else if (pid == 0) {
        // Child process
        execv(argv[0], argv);
        perror("execv"); // execv only returns on error
        fprintf(stderr, "Failed to run: %s\n", argv[0]);
        exit(1);
    } else {
        // Parent process
        int status;
        waitpid(pid, &status, 0);
        return WIFEXITED(status) && WEXITSTATUS(status) == 0? 0 : 1;
    }
}

int main(int argc, char** argv) {
    if (argc < 2) {
        printf("Usage: aria_compiler <input.aria> [--asm-only]\n");
        return 1;
    }

    // 0. Initialize Tool Bundler (Extract nasm/cc/libaria)
    if (!bundler_init()) {
        fprintf(stderr, "Fatal: Failed to initialize bundled toolchain.\n");
        return 1;
    }

    const char* input_file = argv[1];
    int asm_only = (argc >= 3 && strcmp(argv[2], "--asm-only") == 0);

    // 1. Read Source
    char* source = read_entire_file(input_file);
    if (!source) {
        fprintf(stderr, "Error: Could not read file %s\n", input_file);
        return 1;
    }

    // 2. Setup Arena & Parse
    AstArena* arena = arena_create();
    init_lexer(source);
    AstNode* root = parse_program(arena);
    
    // 3. Determine Output Names
    char asm_file[256];
    char obj_file[256];
    char bin_file[256];
    
    replace_extension(input_file, ".asm", asm_file, sizeof(asm_file));
    replace_extension(input_file, ".o", obj_file, sizeof(obj_file));
    replace_extension(input_file, "", bin_file, sizeof(bin_file)); 

    // 4. Codegen
    asm_out = fopen(asm_file, "w");
    if (!asm_out) {
        fprintf(stderr, "Error: Could not open output file %s\n", asm_file);
        return 1;
    }
    
    gen_program(root);
    fclose(asm_out);
    
    arena_free(arena);
    free(source);
    
    printf("[Aria] Generated Assembly: %s\n", asm_file);

    if (asm_only) return 0;

    // 5. Assemble and Link (Secure Execution using Bundled Tools)
    
    // Step A: NASM
    char* nasm_cmd = (char*)bundler_get_nasm_path();
    char* nasm_args[] = { nasm_cmd, "-f", "elf64", asm_file, "-o", obj_file, NULL };
    
    printf("[Aria] Assembling with %s...\n", nasm_cmd);
    if (run_command(nasm_args) != 0) {
        fprintf(stderr, "[Aria] Assembler failed.\n");
        return 1;
    }

    // Step B: Linker (TCC/GCC)
    char* cc_cmd = (char*)bundler_get_cc_path();
    char* runtime_lib = (char*)bundler_get_runtime_path();
    
    // Tesla consciousness security: Include libssh for cryptographic operations
    // Note: -no-pie is standard for ASM linking on modern Linux
    char* link_args[] = {
        cc_cmd, 
        "-o", bin_file, 
        obj_file, 
        runtime_lib,
        "-lm", "-lpthread", "-ldl", "-lssh", 
        NULL
    };

    printf("[Aria] Linking with %s...\n", cc_cmd);
    if (run_command(link_args) != 0) {
        fprintf(stderr, "[Aria] Linker failed. Ensure dependencies are installed.\n");
        return 1;
    }

    // Cleanup object file
    remove(obj_file);

    printf("[Aria] Build Successful: %s\n", bin_file);
    return 0;
}
```

### 4\. Modified File: `Makefile`

Updates:

1.  Builds `bin2c` tool.
2.  Converts `libaria.a`, `tools/nasm`, and `tools/tcc` into C headers.
3.  Compiles `src/runtime/bundler.c` with `-DARIA_BUNDLE_TOOLS`.

<!-- end list -->

```makefile
# Aria_lang/Makefile

CC = gcc

# Optimization flags are critical for AI tensor operations and HTTP parsing.
# -D_GNU_SOURCE is required for advanced socket options (SO_REUSEPORT) and threading.
# -DARIA_BUNDLE_TOOLS enables the embedding logic in bundler.c
CFLAGS = -Wall -Wextra -Ofast -march=native -g -std=c99 -D_GNU_SOURCE -DARIA_BUNDLE_TOOLS -Isrc/runtime

# Assembler configuration for low-level optimizations if needed
NASM = nasm
ASMFLAGS = -f elf64

# Libraries required for consciousness computing with secure web server
LIBS = -lm -lpthread -ldl -lssh

SRC = src
BIN = bin
LIB = lib
TOOLS = tools

# Default target builds the preprocessor, compiler, and the static runtime library
all: dirs $(BIN)/bin2c $(LIB)/libaria.a gen_blobs $(BIN)/preprocessor $(BIN)/aria_compiler

dirs:
	@mkdir -p $(BIN) $(LIB) $(TOOLS)

# --- Tool Bundling Logic ---

# compile helper tool
$(BIN)/bin2c: utils/bin2c.c
	@mkdir -p utils
	$(CC) utils/bin2c.c -o $(BIN)/bin2c

# Generate C headers from binaries
gen_blobs: $(LIB)/libaria.a
	@echo "Bundling Tools..."
	@# If tools/nasm exists, bundle it, else warn
	@if [ -f $(TOOLS)/nasm ]; then \
		$(BIN)/bin2c $(TOOLS)/nasm nasm_blob > $(SRC)/runtime/nasm_blob.h; \
	else \
		echo "Warning: tools/nasm not found. Bundler will assume system PATH."; \
		echo "const unsigned char nasm_blob[] = {0}; const unsigned int nasm_blob_len = 0;" > $(SRC)/runtime/nasm_blob.h; \
	fi
	@# If tools/tcc exists, bundle it
	@if [ -f $(TOOLS)/tcc ]; then \
		$(BIN)/bin2c $(TOOLS)/tcc tcc_blob > $(SRC)/runtime/tcc_blob.h; \
	else \
		echo "Warning: tools/tcc not found. Bundler will assume system PATH."; \
		echo "const unsigned char tcc_blob[] = {0}; const unsigned int tcc_blob_len = 0;" > $(SRC)/runtime/tcc_blob.h; \
	fi
	@# Bundle the runtime library we just built
	$(BIN)/bin2c $(LIB)/libaria.a libaria_blob > $(SRC)/runtime/libaria_blob.h

# --- Standard Build Steps ---

# Preprocessor build step
PRE_SRC = $(wildcard $(SRC)/preprocessor/*.c)
$(BIN)/preprocessor: $(PRE_SRC)
	$(CC) $(CFLAGS) -o $@ $^

# Compiler build step
# Includes lexer, parser, AST arena, codegen backend, and the new BUNDLER
COMP_SRC = $(SRC)/main.c \
           $(SRC)/frontend/lexer.c \
           $(SRC)/frontend/parser.c \
           $(SRC)/frontend/arena.c \
           $(SRC)/backend/codegen.c \
           $(SRC)/runtime/bundler.c

$(BIN)/aria_compiler: $(COMP_SRC) gen_blobs
	$(CC) $(CFLAGS) -o $@ $(filter %.c, $(COMP_SRC))

# Runtime Library Build Step
RT_SRC = $(wildcard $(SRC)/runtime/*.c) \
         $(SRC)/stdlib/math.c \
         $(SRC)/stdlib/std_io.c \
         $(SRC)/stdlib/string_utils.c \
         $(SRC)/stdlib/clock.c \
         $(SRC)/stdlib/nonary.c \
         $(SRC)/stdlib/quinary.c \
         $(SRC)/stdlib/io.c \
         $(SRC)/stdlib/dynamic.c \
         $(SRC)/stdlib/dataStructures.c \
         $(SRC)/stdlib/algorithms.c \
         $(SRC)/stdlib/threads.c \
         $(SRC)/stdlib/processes.c \
         $(SRC)/stdlib/terminal.c \
         $(SRC)/stdlib/fs.c \
         $(SRC)/stdlib/mouse.c \
         $(SRC)/stdlib/unix.c \
         $(SRC)/stdlib/linux.c \
         $(SRC)/stdlib/2d_drawing.c \
         $(SRC)/stdlib/3d_drawing.c \
         $(SRC)/stdlib/web.c \
         $(SRC)/stdlib/database.c \
         $(SRC)/stdlib/ai.c \
         $(SRC)/stdlib/tui_components.c \
         $(SRC)/stdlib/gui_components.c \
         $(SRC)/stdlib/window.c \
         $(SRC)/stdlib/fetch.c \
         $(SRC)/stdlib/sound.c \
         $(SRC)/stdlib/gamepad.c \
         $(SRC)/stdlib/ffi.c \
         $(SRC)/stdlib/std_ioe.c \
         $(SRC)/stdlib/atomics.c

# Exclude bundler.c from the runtime library (it belongs to the compiler host)
RT_SRC_FILTERED = $(filter-out $(SRC)/runtime/bundler.c, $(RT_SRC))
RT_OBJ = $(RT_SRC_FILTERED:.c=.o)

$(LIB)/libaria.a: $(RT_OBJ)
	ar rcs $@ $^

# Generic rule for compiling C objects
%.o: %.c
	$(CC) $(CFLAGS) -c $< -o $@

# Cleanup artifacts
clean:
	rm -rf $(BIN) $(LIB) $(SRC)/runtime/*.o $(SRC)/stdlib/*.o $(SRC)/runtime/*_blob.h utils/bin2c

.PHONY: all clean dirs gen_blobs
```

### 5\. New Utility: `utils/bin2c.c`

You need to create this file. It is used by the Makefile to convert binaries to C arrays.

```c
/* Aria_lang/utils/bin2c.c */
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char** argv) {
    if (argc < 3) {
        fprintf(stderr, "Usage: bin2c <input_file> <array_name>\n");
        return 1;
    }

    FILE* f = fopen(argv[1], "rb");
    if (!f) {
        fprintf(stderr, "Could not open %s\n", argv[1]);
        return 1;
    }

    fseek(f, 0, SEEK_END);
    long len = ftell(f);
    fseek(f, 0, SEEK_SET);

    printf("const unsigned int %s_len = %ld;\n", argv[2], len);
    printf("const unsigned char %s[] = {", argv[2]);

    unsigned char buf[1024];
    size_t n;
    int first = 1;
    while ((n = fread(buf, 1, sizeof(buf), f)) > 0) {
        for (size_t i = 0; i < n; i++) {
            if (!first) printf(",");
            printf("0x%02x", buf[i]);
            first = 0;
        }
    }
    printf("};\n");

    fclose(f);
    return 0;
}
```
