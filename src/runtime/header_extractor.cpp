#include "header_extractor.h"
#include <filesystem>
#include <fstream>
#include <iostream>

namespace fs = std::filesystem;

// This will be generated by the CMake build system
// Contains all embedded headers as byte arrays
extern "C" {
    // Generated header data (will be created by CMake)
    extern const EmbeddedHeader embedded_headers[];
    extern const size_t embedded_headers_count;
}

HeaderExtractor::~HeaderExtractor() {
    cleanup();
}

std::string HeaderExtractor::extract_standard_headers() {
    // Create temporary extraction directory
    extraction_path = fs::temp_directory_path() / "aria_headers";
    
    std::error_code ec;
    if (fs::exists(extraction_path)) {
        fs::remove_all(extraction_path, ec);
    }
    
    if (!create_header_directory_structure(extraction_path)) {
        return "";
    }
    
    initialize_header_map();
    
    // Extract all headers
    for (const auto& [name, header] : header_map) {
        std::string header_path = extraction_path + "/" + name;
        
        // Create parent directories
        fs::create_directories(fs::path(header_path).parent_path(), ec);
        
        if (!write_header_file(header_path, header->data, header->size)) {
            std::cerr << "Failed to extract header: " << name << std::endl;
            return "";
        }
    }
    
    return extraction_path;
}

bool HeaderExtractor::extract_header(const std::string& header_name, const std::string& output_path) {
    initialize_header_map();
    
    auto it = header_map.find(header_name);
    if (it == header_map.end()) {
        return false;
    }
    
    return write_header_file(output_path, it->second->data, it->second->size);
}

bool HeaderExtractor::is_header_available(const std::string& header_name) {
    initialize_header_map();
    return header_map.find(header_name) != header_map.end();
}

std::vector<std::string> HeaderExtractor::get_available_headers() {
    initialize_header_map();
    
    std::vector<std::string> headers;
    for (const auto& [name, _] : header_map) {
        headers.push_back(name);
    }
    return headers;
}

void HeaderExtractor::cleanup() {
    if (!extraction_path.empty() && fs::exists(extraction_path)) {
        std::error_code ec;
        fs::remove_all(extraction_path, ec);
        extraction_path.clear();
    }
}

void HeaderExtractor::initialize_header_map() {
    if (!header_map.empty()) {
        return; // Already initialized
    }
    
    // Map all embedded headers
    for (size_t i = 0; i < embedded_headers_count; ++i) {
        const EmbeddedHeader* header = &embedded_headers[i];
        header_map[header->name] = header;
    }
}

bool HeaderExtractor::write_header_file(const std::string& file_path,
                                       const unsigned char* data,
                                       size_t size) {
    std::ofstream file(file_path, std::ios::binary);
    if (!file.is_open()) {
        return false;
    }
    
    file.write(reinterpret_cast<const char*>(data), size);
    return file.good();
}

bool HeaderExtractor::create_header_directory_structure(const std::string& base_path) {
    std::error_code ec;
    
    // Create standard C header directories
    std::vector<std::string> directories = {
        base_path,
        base_path + "/sys",
        base_path + "/arpa",
        base_path + "/net",
        base_path + "/netinet",
        base_path + "/linux",
        base_path + "/asm",
        base_path + "/bits"
    };
    
    for (const auto& dir : directories) {
        fs::create_directories(dir, ec);
        if (ec) {
            return false;
        }
    }
    
    return true;
}

// Fallback implementation if embedded headers not available
// This allows compilation to succeed even without the generated header data
#ifndef EMBEDDED_HEADERS_AVAILABLE
extern "C" {
    const EmbeddedHeader embedded_headers[] = {
        {"stdio.h", nullptr, 0},
        {"stdlib.h", nullptr, 0},
        {"string.h", nullptr, 0},
        // Add more standard headers as needed
    };
    const size_t embedded_headers_count = sizeof(embedded_headers) / sizeof(embedded_headers[0]);
}
#endif