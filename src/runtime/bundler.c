/* Aria_lang/src/runtime/bundler.c */
#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <fcntl.h>
#include <errno.h>
#include "bundler.h"

// These headers are generated by the Makefile
#if defined(ARIA_BUNDLE_TOOLS)
    #include "nasm_blob.h"
    #include "tcc_blob.h"
    #include "libaria_blob.h"
#else
    // Dummy data for development builds without bundling
    const unsigned char nasm_blob[] = {0};
    const unsigned int nasm_blob_len = 0;
    const unsigned char tcc_blob[] = {0};
    const unsigned int tcc_blob_len = 0;
    const unsigned char libaria_blob[] = {0};
    const unsigned int libaria_blob_len = 0;
#endif

static char tool_dir[256];
static char nasm_path[512];
static char cc_path[512];
static char runtime_path[512];
static int initialized = 0;

static void get_temp_dir(char* buffer, size_t size) {
    const char* tmp = getenv("TMPDIR");
    if (!tmp) tmp = "/tmp";
    snprintf(buffer, size, "%s/aria_rt_%d", tmp, getuid());
}

static int write_file_if_missing(const char* path, const unsigned char* data, unsigned int len, int executable) {
    // Check if file exists and has correct size (simple cache check)
    struct stat st;
    if (stat(path, &st) == 0) {
        if (st.st_size == len) return 1; // Assume valid
    }

    FILE* f = fopen(path, "wb");
    if (!f) {
        fprintf(stderr, "[Bundler] Failed to write %s: %s\n", path, strerror(errno));
        return 0;
    }
    
    size_t written = fwrite(data, 1, len, f);
    fclose(f);

    if (written != len) {
        fprintf(stderr, "[Bundler] Write incomplete for %s\n", path);
        return 0;
    }

    if (executable) {
        chmod(path, 0755);
    }
    return 1;
}

int bundler_init() {
    if (initialized) return 1;

    get_temp_dir(tool_dir, sizeof(tool_dir));
    
    // Create directory
    if (mkdir(tool_dir, 0755) != 0 && errno != EEXIST) {
        perror("[Bundler] mkdir failed");
        return 0;
    }

    snprintf(nasm_path, sizeof(nasm_path), "%s/nasm", tool_dir);
    snprintf(cc_path, sizeof(cc_path), "%s/tcc", tool_dir);
    snprintf(runtime_path, sizeof(runtime_path), "%s/libaria.a", tool_dir);

    // Extract Tools
    // Note: If blobs are empty (dev build), we assume tools are in PATH or handled externally
    if (nasm_blob_len > 0) {
        if (!write_file_if_missing(nasm_path, nasm_blob, nasm_blob_len, 1)) return 0;
    } else {
        strcpy(nasm_path, "nasm"); // Fallback to PATH
    }

    if (tcc_blob_len > 0) {
        if (!write_file_if_missing(cc_path, tcc_blob, tcc_blob_len, 1)) return 0;
    } else {
        strcpy(cc_path, "gcc"); // Fallback to PATH
    }

    if (libaria_blob_len > 0) {
        if (!write_file_if_missing(runtime_path, libaria_blob, libaria_blob_len, 0)) return 0;
    } else {
        // Fallback: assume lib/libaria.a relative to CWD
        strcpy(runtime_path, "lib/libaria.a");
    }

    initialized = 1;
    return 1;
}

const char* bundler_get_nasm_path() { return nasm_path; }
const char* bundler_get_cc_path() { return cc_path; }
const char* bundler_get_runtime_path() { return runtime_path; }

void bundler_cleanup() {
    // Optional: Implement rm -rf on tool_dir
}
